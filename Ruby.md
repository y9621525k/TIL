## 2章
- 変数名はスネークケースで書く
```
special_price = 200
```
- ダブルクオートで囲むと\nが改行文字として機能する
- シングルクオートで囲むと文字列になる
- 式展開は#{}
```
name = 'Alice'
puts "Hello, #{name}!" #=> Hello, Alice!
```
```
# nを1増やす(n = n + 1と同じ)
n += 1 #=>2

# 文字列は数値に変換する必要がある
# 整数に変換
1 + '10'.to_i #=> 11
```
- falseまたはnilであれば偽
- それ以外はすべて真
- メソッド名はスネークケースで書く
- returnを使わない書き方のほうが主流。メソッドを途中で脱出する場合に使われる。
- andやorは条件分岐で使うのでなく、制御フローを扱うのに向いている
```
user.valid? && send_mail_to user # (user.valid? && send_mail_to) userとなり構文エラー
user.valid? and send_mail_to user # (user.valid?) && (send_mail_to user)と解釈される
```
- 条件演算子
```
n = 11
n > 10 ? '10より大きい' : '10以下'
#=> "10より大きい"
```
- ?で終わるメソッドは真偽値を返す
- !が付くメソッドは!が付かないメソッドよりも危険
- 非破壊的メソッドと破壊的メソッドの2種類が存在する場合は後者に!が付く(必ずしも破壊的メソッドではない)
```
# case文
case country # 対象のオブジェクトや式
when 'Japan'
  'こんにちは'　# 処理
else
  '???'
end
```
- Rubyの変数にはオブジェクトそのものではなく、オブジェクトへの参照が格納されている
```
# aとbは同じ文字列だが、オブジェクトとしては別物
a = 'hello'
b = 'hello'
a.object_id #=> 70182231931400
b.object_id #=> 70182236321960

# cにbを代入する。bとcはどちらも同じオブジェクト
c = b
c.object_id #=> 70182236321960
```
```
# Dateクラスは組み込みライブラリではないので、そのままでは使用できない
Date.today #=> Nameerror

# dateライブラリを読み込むとDateクラスが使えるようになる
require 'date'
Date.today
```
- 自作のRubyプログラムを読み込む場合は```require_relative```を使用する
- ```require_relative```では自ファイルからの相対パスで読み込むファイルを指定する
- putsメソッドは改行を加えて出力する
- printメソッドは改行を加えない
- pメソッドは改行を加えて出力する。文字列を出力すると、その文字列はダブルクオートで囲まれる
- ppメソッドは大きくて複雑な配列やハッシュ、オブジェクトの内容を見やすく整形して出力する
- putsメソッド、printメソッドは内部的にto_sメソッドを呼び出して変換されている
- pメソッドはinspectメソッドを呼び出している

## 第3章
- テストを自動化するためにテスト用のフレームワークを用いる(Minitest)
```
# テストコートの雛形
require 'minitest/autorun'

class SampleTest < Minitest:Test
  def test_sample
    assert_equal 'RUBY', 'ruby'.upcase
  end
end
```
- テストメソッドはメソッド名をtest_で始める
```
# aとbが等しければパスする
assert_equal b, a

# aが真であればパスする
assert a

# aが偽であればパスする
refute a
```
- テストコードは別ファイルに分け、```require_relative```でテストを行うファイルを参照する。

## 第4章
- 配列とは複数のデータを格納できるオブジェクトのこと
- <<を使うと配列の最後に要素を追加することができる
```
a = []
a << 1
a << 2
a << 3
a #=> [1, 2, 3]
```
- ブロックとはメソッドの引数として渡すことができる処理のかたまり
- Rubyの繰り返し処理には、for文ではなくeachメソッド+ブロックが使用される
```
# プロック処理
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end

# {}用いたブロック処理
numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n| sum+= n }
```
- 改行を含む長いブロックを書く場合はdo...end
- 1行でコンパクトに書きたいときは{}
```
# &とシンボルを使ってシンプルに書く
['ruby', 'java', 'python'].map { |s| s.upcase }
['ruby', 'java', 'python'].map(&:upcase)
```
1. プロックパラメータが1個だけである
2. ブロックの中で呼び出すメソッドには引数がない
3. ブロックの中では、ブロックパラメータに対してメソッドを1回呼び出す以外の処理がない
```
# 最後の値を含む
1..5
# 最後の値を含まない
1...5
```
- テストコードから作成するテスト駆動開発(TDD)で開発する
  - 先にテストを書いて失敗させる
  - テストがパスするような最小限のコードを書く
  - リファクタリングする
- メソッドはテストコードを参照できないので別ファイルから読み込む
- DRY原則：繰り返しを避ける
```
# 和集合
a = [1, 2, 3]
b = [3, 4, 5]
a | b #=> [1, 2, ,3 ,4, 5]

# 差集合1
a - b #=> [1, 2]

# 積集合
a & b #=? [3]
```
- 配列を引数に渡す場合は、「1つの配列」とするか「複数の引数」とするかを検討し、後者の場合は*を使うと配列を展開できる
```
a = []
b = [2, 3]
a.push(1) #=> [1]
a.push(*b)
a #=> [1, 2, 3]
```
```
# %記法
# %wで文字列の配列を作成(!で囲む場合)
%w!apple melon orange! #=> ["apple", "melon", "orange"]

# %wで文字列の配列を作成(丸括弧で囲む場合)
%w(apple melon orange) #=> ["apple", "melon", "orange"]
```
```
# 以下のコードはa = []と同じ
a = Array.new
```
- 繰り返し処理で使うbreakは「繰り返し処理からの脱出」、returnは「メソッドからの脱出」の違いがある
```
def calc_with_return
  numbers = [1, 2, 3, 4, 5, 6]
  target = nil
  numbers.shuffle.each do |n|
    target = n
    return if n.even?
  end
  target * 10
end
calc_with_return #=> nil
# returnには引数を渡していないので、結果としてメソッドの戻り値はnilになる
```

## 第5章
- ハッシュはキーと値の組み合わせでデータを管理するオブジェクトのこと
```
# 要素を追加
ハッシュ[キー] = 値

# ハッシュから値を取り出す
ハッシュ[キー]
```
- シンボルとは、任意の文字列と一対一に対応するオブジェクトのこと
- :シンボルの名前という形で名前を定義する
- シンボルは整数として扱わるので、PCは高速に値を比較することができる。ハッシュのキーとしてシンボルを使用すると文字列よりも高速で取り出すことができる
- 同じシンボルは同じオブジェクトなので、メモリの使用率が良い
```
:シンボル名
```
- メソッドの引数を指定する「キーワード引数」という機能がある
- メソッドの引数にキーワード引数を用いると可読性が上がる
```
def buy_burger(menu, drinK: true, potato: true)
  #省略
end
```
```
# "シンボル: 値"という記法でハッシュを作成できる
currencies = { japan: 'yen', us: 'doller', india: 'rupee' }
currencies[:us] #=> "doller"
```
- keysメソッドはハッシュのキーを配列として返す
```
currencies = { japan: 'yen', us: 'doller', india: 'rupee' }
currencies.keys #=> [:japan, :us, :india]
```
- valuesメソッドはハッシュの値を配列として返す
```
currencies.values #=> ["yen", "doller", "rupee"]
```
- has_key?メソッドはハッシュの中に指定されたキーが存在するかどうか確認するメソッド
- key?/include?/member?はいずれもhas_key?のエイリアスメソッド
```
currencies.has_key?(:japan) #=> true
currencies.has_key?(:italy) #=> false
```

## 6章
- 正規表現:パターンを指定して、文字列を効率よく検索/置換するためのミニ言語
- \d:半角数字1文字を表す
- {n,m}:　直前の文字がn文字以上、m文字以下,{n}:直前の文字がちょうどn文字
- ?:直前の文字が1または無し
- .:任意の1文字
- +:直前の文字が1文字以上
- *:直前の文字が0文字以上
- ():グループ化、キャプチャ
- \w:半角英数字とアンダースコア
- rubyの正規表現:/正規表現/
- キャプチャ()には(?<name>)という形で名前をつけることができ、呼び出しもこの名前で可能

## 7章
- クラスをもとに作られたデータの塊をオブジェクトまたはインスタンスと呼ぶ。
- 上記オブジェクトが持つ「動作、振る舞い」をメソッドと呼ぶ
- 属性:オブジェクトから取得できる(設定できる)値のこと
- クラス内では@で始まるインスタンス変数を使うことができる。
- attr_accecerを使うとクラスの外部からインスタンス変数を呼び出すことが可能
- 上記、読み取り専用にする場合:attr_reader,書き込み専用にする場合:attr_writer
- setupメソッドMinitestが実行されるたびに自動的に呼び出されるMinitest版のinitializeメソッドのようなもの
- selfを使用することで、クラス内でインスタンス変数を使用 or 再代入することが可能になる + インスタンス変数であることがわかりやすくなる。
- class サブクラス < スーパークラスにてサブクラスはスーパークラスの属性継承することが可能になる。
- superで親クラスのメソッドを子クラスで呼び出すことができる。
