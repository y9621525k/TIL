## アセットパイプライン
JavaScript、CSS、画像などのリソース(アセット)を効率的に扱うための仕組み  
開発者が書いたJavaScriptやCSSを、最終的にアプリを使う上で都合の良い状態(ブラウザが読み取れる形式で実行速度が速くブラウザキャッシュに対して最適化される)にするためのパイプライン処理を行う  
sprockets-railsというgemにて提供されるSprocketsの機能で、デフォルトで有効

## 各ディレクトリの構造
appディレクトトリ：Model、View、Controller、helperファイル、Assetファイル
onfigディレクトリ：ルーティング、各種設定ファイル、master.key
dbディレクトリ：データベースのスキーマファイル、マイグレーションファイル

## layoutファイル
Webページを表示する際に必要な情報（html head bodyタグなど）を記載するファイル。Viewページを作成する際に最初に読み込まれる。
デフォルトではapplication.html.erbが読み込まれ、タグやタグの中で <%= yield %> を記載して個別のテンプレートファイルのHTMLを表示する。

## CSSとSCSSの違い
CSSは開発者からすると書きづらい
ex.ネスト記法が使えない, 変数を使えない etc
CSSを効率よく書けるようにしたものがSCSS
ブラウザが解釈できるのはあくまでもCSS
なのでSCSSをCSSにコンパイルする必要がある
Railsでは「アセットパイプライン」という仕組みが勝手にコンパイルをしてくれるので開発者は特に意識する必要はない

## Railsにおける処理の全体像
ブラウザからサーバーにリクエストが送られる。
Railsがリクエストを解析、routingを参照して処理するコントローラとアクションを決定。
コントローラでDBへの参照が必要ならActiveRecordを介してやり取りし、DBから値を取得。
Viewに値を埋め込んでHTMLや画像、cssなどのアセットファイルを含めてブラウザに返す。
ブラウザはレスポンスからHTML,css等を解析して装飾して画面に表示する。
「クライアント → HTTPリクエスト → routing → Controller → Model → DB → View → HTTPレスポンス → クライアント」

## セッション/クッキー
ログインの仕組み
- HTTPリクエストはステートレスなので状態を保持できない
- 1回目のリクエスト・レスポンスと2回目のリクエスト・レスポンスには繋がりがない
- HTTPの仕組み単体ではログイン状態を維持できないことになる
- セッションとはサーバー側で保存される情報
- Cookieとはブラウザ側で保存される情報
- ユーザー情報を識別するための情報をセッションに保存し、そのセッションIDをCookieに載せることでリクエスト間の繋がりを持たせている。

## バリデーション
saveとsave!メソッドの挙動の違い
- saveは失敗したら「false」が返り、save!は「例外」が返る
- saveは失敗を想定している処理に使い、save!は失敗しないはずの処理に使う

## デバッグ
デバッグで確認すること
- paramsなど変数の値が自分の意図したものか
- メソッドの返り値が自分の意図したものか
- 意図した箇所が動いているか
- binding.pryではshow-sourceでメソッドの定義元のコードを確認できる

## Railsにおける多言語化対応
i18nとは
- Railsのアプリケーション内で複数の言語を併用する仕組み
- config/locales下にymlファイルを作成する（英語であればen.yml、日本語であればja.yml)
- userクラスにlocaleという属性を設定し、例えばbeforeアクションでcurrent_userのlocaleを確認するメソッドを定義すればユーザーごとに言語を切り替えられる
- i18nはinternationalizationの略称

## デコレータ
- デコレータとはデザインパターンの一つ
- ビューを汚さないためのデザインパターン
- ビューにロジックを書くとビューが汚れてしまう
- その解決策としてまずモデルにロジックを書くことがあげられる
- ただビューに関する表示ロジックをモデルに書くのも責務的に違和感がある
- 一方でヘルパーを利用するにも問題がある。ヘルパーはグローバル空間を汚染するので別ファイルだとしても同名のメソッドが存在した場合にバッティングするという問題がある
- そこで表示に関するロジック書く場所がデコレータ層

## アソシエーション(has_many, belongs_to)
- アソシエーションの定義をモデルに書くと、オブジェクトからインスタンスメソッドが使えるようになり、関連するモデルの情報を取得できる。
```
# ユーザーオブジェクトを取得
user = User.first
```
```
# userオブジェクトが board_id という外部キーを持っているので、その外部キーを使って、userオブジェクトが作成したboardオブジェクト（Boardモデルのidを参照する）を取得できる。
user.boards
```

## dependent: :destroy
- モデル間のリレーションが設定されている場合、この設定をした親モデルが削除されると、関連する子モデルも同時に削除され、参照先が存在しないというバグを防ぐ。
- UserとBoardモデルがあるとした場合、1人のユーザーは複数の掲示板を投稿できるので、Userモデルにhas_many boards, dependent: :destroyと記載する。そうすると、Userが削除されるとそのユーザーが作成したBoardも消える。

## DB側の制約（not null制約、外部キー制約）
- 一般的に、モデルのバリデーションだけでなくDBレベルでも制約をかけたほうがよい
- Railsを介さずにSQLを直接実行すると意図しない値が入ることがあるため
- Railsを介したとしてもバリデーションを実行しないで保存・更新しようとするメソッドもあるため

## ルーティング（REST）
ユーザー新規作成時は、
- URL：users/:id
- httpメソッド：POSTリクエスト → POST /users
- リソースの作成はPOST, 取得はGET

## includes（N+1問題）
- N+1問題とは、関連付けを持つあるモデル(A)について、検索をかける際に外部キー参照により関連するテーブル(B)の値も合わせて取得しようとした時、「まずAのレコードN件を取得するクエリが１回、次に各Aレコードに対して関連テーブルの値を引っ張ってくるクエリがN回発行されてしまう」という問題
- 例:一覧画面のViewでboard.user.first_nameなど関連するモデルの値を複数回取得する処理
- 対策:includesなどのメソッドによって読み込まれるすべての関連付けを事前に指定する方法がある

## フォームヘルパー(form_with)
- form_withメソッドの嬉しさ
- form_withのmodelオプションに渡されたインスタンスを見て、よしなにPOSTだったりPATCHだったりを設定してくれる。
- フォームの各フィールドのname属性に適切な命名を自動的につけてくれたり、編集時においては現在の値を初期表示してくれたりする。
- CSRFトークンの発行も自動的にしてくれる

## renderとredirect_toの違い
- render ・・・(文・絵で)(…を)表現する、描写する
- renderは当該リクエストに対するレスポンスとして、描画したHTMLを返します。
- redirect ・・・再び(re)指示する(direct)
- redirectは当該リクエストに対するレスポンスとして、「ブラウザさん、続いてここにリクエスト送ってね」という指示を返します。

## ストロングパラメータ
- 入力フォームに無い属性のデータをrequestに含められた場合に、それによるデータの更新を防ぐことができる。
- マスアサイメント機能を使うと意図せぬ属性が紛れ込んだ場合に想定外の属性についても登録・更新されてしまう（admin: true と更新されるなど）
- そのためストロングパラメーターで更新を許可するパラメータを決めておく。

## マイグレーション全般
- SQLクエリを書かずにテーブル情報の追加、変更が行えるため、誤ったクエリの実行によってDBスキーマを変更するリスクが下がる。
- DBスキーマを直接変更するのではなくmigrationファイルを追加してテーブルを変更していくので、複数人でテーブル情報の更新を行う際に変更が競合しづらい。
- migrationファイルが実行順にファイルとして残り、rollbackでどの時点のテーブルの状態まで戻す、といった作業が行いやすい。
- DBのテーブル・カラムに関する変更履歴が実行順で残る。

## ロールバック
- マイグレーションファイルに対して、直前に実行されたマイグレーションの処理を取り消して、DBを反映前の状態に戻すこと。
- ロールバックによって未実行となったマイグレーションファイルは状態がupからdownになり、次にマイグレーションを実行すると反映される。
- 同じロールバックでもDBのトランザクションに対するロールバックの場合は、トランザクション中の処理を取り消して処理前の状態に戻すことを意味する。

## バリデーションエラー発生時の挙動(バリデーションエラーが発生したときのメッセージ)
```
<%= @user.errors.full_messages.each do |message| %>
  <%= message %>
<% end %>
```
- errors : 各カラムに対し発生したエラー内容を文字列の配列として保管したインスタンスを取得。
- full_messages : 実際にビューに表示するのに適した文章に整形されたメッセージの配列を取得する。
- eachで配列からエラー文を1つずつ取り出し順に表示させる

## scope
モデルでscopeを設定するメリット
- 頻繁に使用されるクエリに名前をつけて設定しておくことができ、コードが短く、かつ直感的に理解しやすくなる。
- 複雑な検索メソッドや長いメソッドチェーンなど読みにくいものにラベルを付けることで可読性が上がり再利用しやすくなる。

## resoursesのネスト
- ネストは、モデル間で関連付けが設定されており、親子両方の情報をURLに含めたい場合に使用する。
```
routes.rb
resources :boards do
  resources :comments
end
# => /boards/:board_id/comments/:comment_id といったURLが得られる
```
