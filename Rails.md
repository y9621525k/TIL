## アセットパイプライン
JavaScript、CSS、画像などのリソース(アセット)を効率的に扱うための仕組み  
開発者が書いたJavaScriptやCSSを、最終的にアプリを使う上で都合の良い状態(ブラウザが読み取れる形式で実行速度が速くブラウザキャッシュに対して最適化される)にするためのパイプライン処理を行う  
sprockets-railsというgemにて提供されるSprocketsの機能で、デフォルトで有効

## 各ディレクトリの構造
appディレクトトリ：Model、View、Controller、helperファイル、Assetファイル
onfigディレクトリ：ルーティング、各種設定ファイル、master.key
dbディレクトリ：データベースのスキーマファイル、マイグレーションファイル

## layoutファイル
Webページを表示する際に必要な情報（html head bodyタグなど）を記載するファイル。Viewページを作成する際に最初に読み込まれる。
デフォルトではapplication.html.erbが読み込まれ、タグやタグの中で <%= yield %> を記載して個別のテンプレートファイルのHTMLを表示する。

## CSSとSCSSの違い
CSSは開発者からすると書きづらい
ex.ネスト記法が使えない, 変数を使えない etc
CSSを効率よく書けるようにしたものがSCSS
ブラウザが解釈できるのはあくまでもCSS
なのでSCSSをCSSにコンパイルする必要がある
Railsでは「アセットパイプライン」という仕組みが勝手にコンパイルをしてくれるので開発者は特に意識する必要はない

## Railsにおける処理の全体像
ブラウザからサーバーにリクエストが送られる。
Railsがリクエストを解析、routingを参照して処理するコントローラとアクションを決定。
コントローラでDBへの参照が必要ならActiveRecordを介してやり取りし、DBから値を取得。
Viewに値を埋め込んでHTMLや画像、cssなどのアセットファイルを含めてブラウザに返す。
ブラウザはレスポンスからHTML,css等を解析して装飾して画面に表示する。
「クライアント → HTTPリクエスト → routing → Controller → Model → DB → View → HTTPレスポンス → クライアント」

## セッション/クッキー
ログインの仕組み
- HTTPリクエストはステートレスなので状態を保持できない
- 1回目のリクエスト・レスポンスと2回目のリクエスト・レスポンスには繋がりがない
- HTTPの仕組み単体ではログイン状態を維持できないことになる
- セッションとはサーバー側で保存される情報
- Cookieとはブラウザ側で保存される情報
- ユーザー情報を識別するための情報をセッションに保存し、そのセッションIDをCookieに載せることでリクエスト間の繋がりを持たせている。

## バリデーション
saveとsave!メソッドの挙動の違い
- saveは失敗したら「false」が返り、save!は「例外」が返る
- saveは失敗を想定している処理に使い、save!は失敗しないはずの処理に使う

## デバッグ
デバッグで確認すること
- paramsなど変数の値が自分の意図したものか
- メソッドの返り値が自分の意図したものか
- 意図した箇所が動いているか
- binding.pryではshow-sourceでメソッドの定義元のコードを確認できる

## Railsにおける多言語化対応
i18nとは
- Railsのアプリケーション内で複数の言語を併用する仕組み
- config/locales下にymlファイルを作成する（英語であればen.yml、日本語であればja.yml)
- userクラスにlocaleという属性を設定し、例えばbeforeアクションでcurrent_userのlocaleを確認するメソッドを定義すればユーザーごとに言語を切り替えられる
- i18nはinternationalizationの略称

## デコレータ
- デコレータとはデザインパターンの一つ
- ビューを汚さないためのデザインパターン
- ビューにロジックを書くとビューが汚れてしまう
- その解決策としてまずモデルにロジックを書くことがあげられる
- ただビューに関する表示ロジックをモデルに書くのも責務的に違和感がある
- 一方でヘルパーを利用するにも問題がある。ヘルパーはグローバル空間を汚染するので別ファイルだとしても同名のメソッドが存在した場合にバッティングするという問題がある
- そこで表示に関するロジック書く場所がデコレータ層

## アソシエーション(has_many, belongs_to)
- アソシエーションの定義をモデルに書くと、オブジェクトからインスタンスメソッドが使えるようになり、関連するモデルの情報を取得できる。
```
# ユーザーオブジェクトを取得
user = User.first
```
```
# userオブジェクトが board_id という外部キーを持っているので、その外部キーを使って、userオブジェクトが作成したboardオブジェクト（Boardモデルのidを参照する）を取得できる。
user.boards
```

## dependent: :destroy
- モデル間のリレーションが設定されている場合、この設定をした親モデルが削除されると、関連する子モデルも同時に削除され、参照先が存在しないというバグを防ぐ。
- UserとBoardモデルがあるとした場合、1人のユーザーは複数の掲示板を投稿できるので、Userモデルにhas_many boards, dependent: :destroyと記載する。そうすると、Userが削除されるとそのユーザーが作成したBoardも消える。

## DB側の制約（not null制約、外部キー制約）
- 一般的に、モデルのバリデーションだけでなくDBレベルでも制約をかけたほうがよい
- Railsを介さずにSQLを直接実行すると意図しない値が入ることがあるため
- Railsを介したとしてもバリデーションを実行しないで保存・更新しようとするメソッドもあるため

## ルーティング（REST）
ユーザー新規作成時は、
- URL：users/:id
- httpメソッド：POSTリクエスト → POST /users
- リソースの作成はPOST, 取得はGET

## includes（N+1問題）
- N+1問題とは、関連付けを持つあるモデル(A)について、検索をかける際に外部キー参照により関連するテーブル(B)の値も合わせて取得しようとした時、「まずAのレコードN件を取得するクエリが１回、次に各Aレコードに対して関連テーブルの値を引っ張ってくるクエリがN回発行されてしまう」という問題
- 例:一覧画面のViewでboard.user.first_nameなど関連するモデルの値を複数回取得する処理
- 対策:includesなどのメソッドによって読み込まれるすべての関連付けを事前に指定する方法がある

## フォームヘルパー(form_with)
- form_withメソッドの嬉しさ
- form_withのmodelオプションに渡されたインスタンスを見て、よしなにPOSTだったりPATCHだったりを設定してくれる。
- フォームの各フィールドのname属性に適切な命名を自動的につけてくれたり、編集時においては現在の値を初期表示してくれたりする。
- CSRFトークンの発行も自動的にしてくれる

## renderとredirect_toの違い
- render ・・・(文・絵で)(…を)表現する、描写する
- renderは当該リクエストに対するレスポンスとして、描画したHTMLを返します。
- redirect ・・・再び(re)指示する(direct)
- redirectは当該リクエストに対するレスポンスとして、「ブラウザさん、続いてここにリクエスト送ってね」という指示を返します。

## ストロングパラメータ
- 入力フォームに無い属性のデータをrequestに含められた場合に、それによるデータの更新を防ぐことができる。
- マスアサイメント機能を使うと意図せぬ属性が紛れ込んだ場合に想定外の属性についても登録・更新されてしまう（admin: true と更新されるなど）
- そのためストロングパラメーターで更新を許可するパラメータを決めておく。

## マイグレーション全般
- SQLクエリを書かずにテーブル情報の追加、変更が行えるため、誤ったクエリの実行によってDBスキーマを変更するリスクが下がる。
- DBスキーマを直接変更するのではなくmigrationファイルを追加してテーブルを変更していくので、複数人でテーブル情報の更新を行う際に変更が競合しづらい。
- migrationファイルが実行順にファイルとして残り、rollbackでどの時点のテーブルの状態まで戻す、といった作業が行いやすい。
- DBのテーブル・カラムに関する変更履歴が実行順で残る。

## ロールバック
- マイグレーションファイルに対して、直前に実行されたマイグレーションの処理を取り消して、DBを反映前の状態に戻すこと。
- ロールバックによって未実行となったマイグレーションファイルは状態がupからdownになり、次にマイグレーションを実行すると反映される。
- 同じロールバックでもDBのトランザクションに対するロールバックの場合は、トランザクション中の処理を取り消して処理前の状態に戻すことを意味する。

## バリデーションエラー発生時の挙動(バリデーションエラーが発生したときのメッセージ)
```
<%= @user.errors.full_messages.each do |message| %>
  <%= message %>
<% end %>
```
- errors : 各カラムに対し発生したエラー内容を文字列の配列として保管したインスタンスを取得。
- full_messages : 実際にビューに表示するのに適した文章に整形されたメッセージの配列を取得する。
- eachで配列からエラー文を1つずつ取り出し順に表示させる

## scope
モデルでscopeを設定するメリット
- 頻繁に使用されるクエリに名前をつけて設定しておくことができ、コードが短く、かつ直感的に理解しやすくなる。
- 複雑な検索メソッドや長いメソッドチェーンなど読みにくいものにラベルを付けることで可読性が上がり再利用しやすくなる。

## resoursesのネスト
- ネストは、モデル間で関連付けが設定されており、親子両方の情報をURLに含めたい場合に使用する。
```
routes.rb
resources :boards do
  resources :comments
end
# => /boards/:board_id/comments/:comment_id といったURLが得られる
```

## 他人の掲示板を編集・削除しようとした際の制御
- BoardsControllerのedit update destroyアクションで Board.findを使ってリソースを取得した場合、他のユーザーの掲示板も含めたBoard全体からfindしているので、他人の掲示板の編集ページを表示したり、更新・削除できる可能性がある（URL直打ちやcurl -XPOSTなどのターミナル操作）
- 望ましい記載としては、Boardからでは無くcurrent_user.boardsからfindさせれば良い。
```
def edit
  @board = current_user.boards.find(params[:id])
end
```

## application.html.erbのyield
application.html.erbのyieldとテンプレートファイルについて
- テンプレートファイルからレンダリングしたものがyieldと書いた箇所に挿入されるイメージ

## collectionルーティング
memberとcollectionルーティングの使い分け
- resourcesで自動生成される7つのアクションの他に、新たに独自のアクションを追加する場合は合わせてルーティングも設定する必要がある。
- その際リソースのIDが不要なアクション（インスタンスの検索など）はcollectionを、必要なアクション（あるインスタンスのプレビュー表示など）ならばmemberを使用する。

## has_many through
- has_many through アソシエーションを設定すると、多対多の関連付けを簡潔に表現できる。
- 中間テーブルを意識せずに他方のモデルを取得できる

## Railsにおけるajax処理
- ajaxとはJavaScriptを用い非同期通信を行う。
- リクエストに対し画面全体をリロードする必要がなく、変更が必要な部分だけを動的に再表示する。
- リクエストに対する返答を待つ間もユーザーは操作を行うことができる。

## data-remote="true"によるajax処理
data-remote="true"がついたフォームを送信した際の挙動
- rails-ujsの機能により非同期通信が行われる
- 特に指定をしない限りxxx.js.erbテンプレートを使ってレスポンスが生成される
- rails-ujsのイベントハンドラをセットしておくことで処理成功時/失敗時の動きをハンドリングできる

## debuggerを使ったブラウザの検証ツールによるJavascriptコードのデバッグ
JavaScriptのデバッグをターミナルではなく、ブラウザの検証ツールで行わなければならない理由
- JSはフロントエンド（ブラウザで動作する、DOMオブジェクトを操作する）言語なので、サーバー側では動作せず、ターミナルでは実行されるコードの状況を確認できない。
- そのためクライアント側の検証ツールで確認する必要がある。

## 単一resource（ルーティング）
単数系リソースの使い方、resourcesとの違い
- 自分のプロフィール等ユーザ視点から1つしか見えないようなモデルに対して使う。
- resouceで定義したルーティングでは当然だがindexは作られない。
- :idもルーティングに含まれない
- アプリケーション内でユーザーがただひとつしか操作できないものを表現するときに単数リソースを使う。例えば、アカウント情報はそれぞれのユーザーが持っているため複数あるように思えるが、ユーザーは自身のアカウントしか意識できない(=他人のアカウント情報は見えない)し、2つのアカウントを持つこともできない。よって、アカウント情報には単数リソースを用いる。
- 反対に、記事などは一人のユーザーが複数作成できるので、普通のリソース(resources)を用いる。たとえば「ユーザーは自分のプロフィール情報のみを確認・編集できる」というシステムの場合には、あらゆるユーザーは確実に、自身のプロフィールただ1つにのみアクセスすることとなり、他人のプロフィールにアクセスする可能性はない。その場合ユーザーのIDの情報はシステムが内部的に保持していればよく、URLに視認できる状態で含める意味はない。この場合に単数形リソースを使用することで、通常/profile/:id/editのようになるURLを、/profile/editという形で生成できる。

## モデルに紐づかないコントローラの実装
- Profile機能（詳細、編集）では対象のリソースが自分のProfileに限定されることから、ルーティングにUserのIDを必要としないため
- paramsから取得できるIDが無くても、current_userを利用して自分のProfile（Userモデル）を特定することができる。
```
profiles_controller.rb
user = User.find(current_user.id)
```
- Profile機能（詳細、編集）をUsersControllerに記載しないことで、詳細や編集で```params[:id]```でfindすることで誤ったProfileの詳細を見たり、編集したりといった挙動が発生しないようにできる。

## パスワードリセット機能
パスワードリセットの機能大まかな流れ
- ユーザーはパスワードリセットをする画面を開く
- メールアドレスを入力してサブミットする
- サーバー側では入力されたメールアドレスをもとにユーザーを特定し、ユニークなトークンを発行して同レコードに保存する。そのトークンを含めたパスワード変更用のページのURLをメールに埋め込む。
- メールを受け取ったユーザーはそのURLを踏む
- サーバー側ではURLに含まれたトークンを元にユーザーを特定し、パスワード変更用の画面をレンダリングする
- ユーザーは変更後のパスワードを入力し、サブミットする（送信先のURLにもトークンが含まれている）
- サーバー側ではURLに含まれたトークンを元にユーザーを特定し、送信されてきたパスワードのパラメータを使ってユーザーのパスワードを変更する

## gem config
- 定数を一言管理できる
- 開発環境、本番環境、テスト環境で異なる値を使用したい時に便利
