## アセットパイプライン
JavaScript、CSS、画像などのリソース(アセット)を効率的に扱うための仕組み  
開発者が書いたJavaScriptやCSSを、最終的にアプリを使う上で都合の良い状態(ブラウザが読み取れる形式で実行速度が速くブラウザキャッシュに対して最適化される)にするためのパイプライン処理を行う  
sprockets-railsというgemにて提供されるSprocketsの機能で、デフォルトで有効

## 各ディレクトリの構造
appディレクトトリ：Model、View、Controller、helperファイル、Assetファイル
onfigディレクトリ：ルーティング、各種設定ファイル、master.key
dbディレクトリ：データベースのスキーマファイル、マイグレーションファイル

## layoutファイル
Webページを表示する際に必要な情報（html head bodyタグなど）を記載するファイル。Viewページを作成する際に最初に読み込まれる。
デフォルトではapplication.html.erbが読み込まれ、タグやタグの中で <%= yield %> を記載して個別のテンプレートファイルのHTMLを表示する。

## CSSとSCSSの違い
CSSは開発者からすると書きづらい
ex.ネスト記法が使えない, 変数を使えない etc
CSSを効率よく書けるようにしたものがSCSS
ブラウザが解釈できるのはあくまでもCSS
なのでSCSSをCSSにコンパイルする必要がある
Railsでは「アセットパイプライン」という仕組みが勝手にコンパイルをしてくれるので開発者は特に意識する必要はない

## Railsにおける処理の全体像
ブラウザからサーバーにリクエストが送られる。
Railsがリクエストを解析、routingを参照して処理するコントローラとアクションを決定。
コントローラでDBへの参照が必要ならActiveRecordを介してやり取りし、DBから値を取得。
Viewに値を埋め込んでHTMLや画像、cssなどのアセットファイルを含めてブラウザに返す。
ブラウザはレスポンスからHTML,css等を解析して装飾して画面に表示する。
「クライアント → HTTPリクエスト → routing → Controller → Model → DB → View → HTTPレスポンス → クライアント」

## セッション/クッキー
ログインの仕組み
- HTTPリクエストはステートレスなので状態を保持できない
- 1回目のリクエスト・レスポンスと2回目のリクエスト・レスポンスには繋がりがない
- HTTPの仕組み単体ではログイン状態を維持できないことになる
- セッションとはサーバー側で保存される情報
- Cookieとはブラウザ側で保存される情報
- ユーザー情報を識別するための情報をセッションに保存し、そのセッションIDをCookieに載せることでリクエスト間の繋がりを持たせている。

## バリデーション
saveとsave!メソッドの挙動の違い
- saveは失敗したら「false」が返り、save!は「例外」が返る
- saveは失敗を想定している処理に使い、save!は失敗しないはずの処理に使う

## デバッグ
デバッグで確認すること
- paramsなど変数の値が自分の意図したものか
- メソッドの返り値が自分の意図したものか
- 意図した箇所が動いているか
- binding.pryではshow-sourceでメソッドの定義元のコードを確認できる

## Railsにおける多言語化対応
i18nとは
- Railsのアプリケーション内で複数の言語を併用する仕組み
- config/locales下にymlファイルを作成する（英語であればen.yml、日本語であればja.yml)
- userクラスにlocaleという属性を設定し、例えばbeforeアクションでcurrent_userのlocaleを確認するメソッドを定義すればユーザーごとに言語を切り替えられる
- i18nはinternationalizationの略称

## デコレータ
- デコレータとはデザインパターンの一つ
- ビューを汚さないためのデザインパターン
- ビューにロジックを書くとビューが汚れてしまう
- その解決策としてまずモデルにロジックを書くことがあげられる
- ただビューに関する表示ロジックをモデルに書くのも責務的に違和感がある
- 一方でヘルパーを利用するにも問題がある。ヘルパーはグローバル空間を汚染するので別ファイルだとしても同名のメソッドが存在した場合にバッティングするという問題がある
- そこで表示に関するロジック書く場所がデコレータ層

## アソシエーション(has_many, belongs_to)
- アソシエーションの定義をモデルに書くと、オブジェクトからインスタンスメソッドが使えるようになり、関連するモデルの情報を取得できる。
```
# ユーザーオブジェクトを取得
user = User.first
```
```
# userオブジェクトが board_id という外部キーを持っているので、その外部キーを使って、userオブジェクトが作成したboardオブジェクト（Boardモデルのidを参照する）を取得できる。
user.boards
```
